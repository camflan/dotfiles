#!/usr/bin/env bash
set -e
set -u
set -o pipefail

show_help() {
    cat << EOF
Usage: serveit [options] [port]

Start a local HTTP server for the current directory.
Automatically renders .md files as HTML when python3 is available.

Options:
  --no-markdown     Disable markdown rendering
  -h, --help        Show this help message

Arguments:
  port              Port to serve on (default: 8000)

Examples:
  serveit           # Serve with markdown rendering on port 8000
  serveit 3000      # Serve with markdown rendering on port 3000
  serveit --no-markdown 8000   # Disable markdown rendering

Features:
  - Renders markdown files as styled HTML
  - Auto-reloads browser when files change
  - Supports Mermaid diagrams
  - Tables, code blocks, blockquotes
  - GitHub-flavored styling

EOF
}

# Default options
port='8000'
markdown_mode=true

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --no-markdown)
            markdown_mode=false
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -*)
            echo "Error: Unknown option '$1'" >&2
            echo "Use -h for help" >&2
            exit 1
            ;;
        *)
            port="$1"
            shift
            ;;
    esac
done

# Markdown rendering server (Python 3 only)
if [[ "$markdown_mode" == true ]] && hash python3 2>/dev/null; then
    echo "Starting server with markdown rendering on port $port..."
    echo "Auto-reload enabled - browser will refresh when files change"
    echo "Press Ctrl+C to stop"
    echo ""

    exec python3 - "$port" <<'PYTHON_EOF'
import sys
import os
from http.server import ThreadingHTTPServer, SimpleHTTPRequestHandler
from urllib.parse import unquote
import mimetypes
import time
from pathlib import Path
import threading
import json

# Try to import markdown library
try:
    import markdown
    HAS_MARKDOWN = True
except ImportError:
    HAS_MARKDOWN = False
    print("Warning: 'markdown' library not found. Install with: pip3 install markdown")
    print("Falling back to plain text rendering for .md files\n")

# File watcher for auto-reload
class FileWatcher:
    def __init__(self):
        self.file_times = {}
        self.lock = threading.Lock()
        self.changed = False

    def watch_file(self, path):
        """Track a file and record its modification time"""
        try:
            mtime = os.path.getmtime(path)
            with self.lock:
                if path not in self.file_times:
                    self.file_times[path] = mtime
                elif self.file_times[path] != mtime:
                    self.file_times[path] = mtime
                    self.changed = True
        except OSError:
            pass

    def check_changes(self):
        """Check all tracked files for changes"""
        with self.lock:
            for path in list(self.file_times.keys()):
                try:
                    mtime = os.path.getmtime(path)
                    if self.file_times[path] != mtime:
                        self.file_times[path] = mtime
                        self.changed = True
                except OSError:
                    # File deleted
                    del self.file_times[path]
                    self.changed = True

            if self.changed:
                self.changed = False
                return True
            return False

watcher = FileWatcher()

class MarkdownHTTPRequestHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
        # Decode the URL path
        path = unquote(self.path.split('?')[0])

        # Handle auto-reload SSE endpoint
        if path == '/__reload__':
            self.send_response(200)
            self.send_header('Content-Type', 'text/event-stream')
            self.send_header('Cache-Control', 'no-cache')
            self.send_header('Connection', 'keep-alive')
            self.end_headers()

            # Send periodic checks for file changes
            try:
                while True:
                    if watcher.check_changes():
                        self.wfile.write(b'data: reload\n\n')
                        self.wfile.flush()
                    time.sleep(0.5)
            except (BrokenPipeError, ConnectionResetError):
                pass
            return

        # Remove leading slash and handle empty path
        if path.startswith('/'):
            path = path[1:]
        if not path:
            path = '.'

        # Check if it's a markdown file
        if os.path.isfile(path) and path.endswith('.md'):
            # Watch this file for changes
            watcher.watch_file(path)
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    content = f.read()

                if HAS_MARKDOWN:
                    # Process mermaid diagrams before markdown rendering
                    # Replace ```mermaid blocks with <pre class="mermaid"> tags
                    import re

                    def replace_mermaid(match):
                        diagram_content = match.group(1)
                        return f'<pre class="mermaid">\n{diagram_content}\n</pre>'

                    # Replace mermaid code blocks
                    content = re.sub(
                        r'```mermaid\n(.*?)\n```',
                        replace_mermaid,
                        content,
                        flags=re.DOTALL
                    )

                    # Render markdown to HTML
                    html_content = markdown.markdown(
                        content,
                        extensions=['fenced_code', 'tables', 'nl2br', 'sane_lists']
                    )
                else:
                    # Fallback: wrap in <pre> tag
                    html_content = f'<pre>{content}</pre>'

                # Create full HTML page
                html = f'''<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{os.path.basename(path)}</title>
    <style>
        body {{
            max-width: 800px;
            margin: 40px auto;
            padding: 0 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }}
        pre {{
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
        }}
        code {{
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: "SF Mono", Monaco, "Cascadia Code", "Roboto Mono", Consolas, monospace;
            font-size: 0.9em;
        }}
        pre code {{
            background: none;
            padding: 0;
        }}
        table {{
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }}
        th, td {{
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }}
        th {{
            background: #f4f4f4;
            font-weight: 600;
        }}
        blockquote {{
            border-left: 4px solid #ddd;
            margin: 15px 0;
            padding-left: 15px;
            color: #666;
        }}
        a {{
            color: #0066cc;
            text-decoration: none;
        }}
        a:hover {{
            text-decoration: underline;
        }}
        h1, h2, h3, h4, h5, h6 {{
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }}
        h1 {{
            font-size: 2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.3em;
        }}
        h2 {{
            font-size: 1.5em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.3em;
        }}
        img {{
            max-width: 100%;
            height: auto;
        }}
        .mermaid {{
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 4px;
            text-align: center;
        }}
    </style>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({{ startOnLoad: true, theme: 'default' }});
    </script>
    <script>
        // Auto-reload via SSE â€” EventSource auto-reconnects on transient errors
        const evtSrc = new EventSource('/__reload__');
        evtSrc.onmessage = function(event) {{
            if (event.data === 'reload') location.reload();
        }};
    </script>
</head>
<body>
{html_content}
</body>
</html>'''

                # Send response
                self.send_response(200)
                self.send_header('Content-type', 'text/html; charset=utf-8')
                self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
                self.end_headers()
                self.wfile.write(html.encode('utf-8'))
                return
            except Exception as e:
                self.send_error(500, f"Error rendering markdown: {str(e)}")
                return

        # For non-markdown files, use default handler
        super().do_GET()

if __name__ == '__main__':
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8000
    server = ThreadingHTTPServer(('localhost', port), MarkdownHTTPRequestHandler)
    print(f'Serving HTTP on http://localhost:{port}/ ...')
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print('\nShutting down server...')
        server.shutdown()
PYTHON_EOF
fi

# Standard server without markdown rendering
if hash php 2>/dev/null; then
  exec php -S "localhost:$port"
elif hash python3 2>/dev/null; then
  exec python3 -m http.server "$port"
elif hash python 2>/dev/null; then
  major_version="$(python -c 'import platform as p;print(p.python_version_tuple()[0])')"
  if [[ "$major_version" == '3' ]]; then
    exec python -m http.server "$port"
  else
    exec python -m SimpleHTTPServer "$port"
  fi
elif hash ruby 2>/dev/null; then
  exec ruby -run -e httpd . -p "$port"
else
  echo 'unable to start HTTP server' 1>&2
  exit 1
fi
