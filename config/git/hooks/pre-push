#!/bin/sh
#
# A pre-push hook that detects new TODO/FIXME/etc comments added in the commits
# being pushed and prompts the user to confirm before proceeding.
#
# Called by "git push" after it has checked the remote status, but before anything
# has been pushed. If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

# Keywords to search for (case-insensitive)
keywords="TODO|FIXME|XXX|HACK|NOTE|BUG"

# Color codes for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Track if we found any comments
found_comments=false
temp_file=$(mktemp)

while read local_ref local_oid remote_ref remote_oid
do
    if test "$local_oid" = "$zero"
    then
        # Handle delete - nothing to check
        continue
    fi

    if test "$remote_oid" = "$zero"
    then
        # New branch, examine all commits
        # Compare against main or master
        main_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
        if [ -z "$main_branch" ]; then
            # Fallback to checking for main or master
            if git rev-parse --verify origin/main >/dev/null 2>&1; then
                main_branch="origin/main"
            elif git rev-parse --verify origin/master >/dev/null 2>&1; then
                main_branch="origin/master"
            else
                # If we can't find a main branch, just check the commits themselves
                range="$local_oid"
            fi
        else
            main_branch="origin/$main_branch"
        fi

        if [ -n "$main_branch" ]; then
            range="$main_branch..$local_oid"
        fi
    else
        # Update to existing branch, examine new commits
        range="$remote_oid..$local_oid"
    fi

    # Get the diff for the range and search for comment keywords
    # We look for added lines (starting with +) that contain our keywords
    git diff "$range" | grep "^+" | grep -iE "($keywords)" > "$temp_file" 2>/dev/null

    if [ -s "$temp_file" ]; then
        found_comments=true

        echo ""
        echo "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo "${YELLOW}⚠  Found new TODO/FIXME comments in commits being pushed:${NC}"
        echo "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        # Get more detailed information with file names and context
        # Use git log with patch to show where these comments are
        git log --no-merges --oneline --no-decorate "$range" | while read commit_line; do
            commit_sha=$(echo "$commit_line" | awk '{print $1}')
            commit_msg=$(echo "$commit_line" | cut -d' ' -f2-)

            # Check if this commit has any of our keywords
            if git show "$commit_sha" | grep "^+" | grep -qiE "($keywords)"; then
                echo "${BLUE}Commit: $commit_sha${NC} - $commit_msg"

                # Show the files and lines with the keywords
                git show --no-patch --format="" "$commit_sha" >/dev/null
                git show --format="" "$commit_sha" | grep -B1 "^+" | grep -iE "(^\+.*($keywords)|^diff --git)" | \
                while IFS= read -r line; do
                    if echo "$line" | grep -q "^diff --git"; then
                        # Extract filename
                        filename=$(echo "$line" | sed 's/diff --git a\/.* b\/\(.*\)/\1/')
                        echo "  ${GREEN}$filename${NC}"
                    elif echo "$line" | grep -qE "^\+"; then
                        # Show the added line with the keyword highlighted
                        clean_line=$(echo "$line" | sed 's/^+//')
                        echo "    ${RED}+${NC} $clean_line"
                    fi
                done
                echo ""
            fi
        done

        echo "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    fi
done

# Clean up
rm -f "$temp_file"

# If we found comments, prompt the user
if [ "$found_comments" = true ]; then
    echo ""
    printf "${YELLOW}Continue with push?${NC} [y/N] "

    # Read from terminal even if stdin is redirected
    if [ -t 0 ]; then
        read -r response
    else
        read -r response < /dev/tty
    fi

    case "$response" in
        [yY][eE][sS]|[yY])
            echo "${GREEN}✓ Proceeding with push...${NC}"
            exit 0
            ;;
        *)
            echo "${RED}✗ Push aborted.${NC}"
            exit 1
            ;;
    esac
fi

exit 0
